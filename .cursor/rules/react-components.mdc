---
globs: *.tsx
description: React コンポーネントのパターンとベストプラクティス
---

# React コンポーネントパターン

## コンポーネント構造

### 基本構造
```typescript
import { useState, useEffect } from 'react';
import type { SomeType } from '../types';

interface ComponentProps {
  prop1: string;
  prop2?: number;
  onAction: () => void;
}

export function Component({ prop1, prop2, onAction }: ComponentProps) {
  // 1. Hooks (カスタムフック)
  const { data } = useGameDataStore();
  
  // 2. State
  const [localState, setLocalState] = useState<string>('');
  
  // 3. Effects
  useEffect(() => {
    // ...
  }, [dependency]);
  
  // 4. Event handlers
  const handleClick = () => {
    onAction();
  };
  
  // 5. Render
  return (
    <div>
      {/* JSX */}
    </div>
  );
}
```

## コード分割 (Lazy Loading)

重いコンポーネントは遅延読み込み:
```typescript
// App.tsx での例
const ModSettings = lazy(() => import('./components/ModSettings').then(m => ({ default: m.ModSettings })));
const WelcomeModal = lazy(() => import('./components/WelcomeModal').then(m => ({ default: m.WelcomeModal })));

// 使用時は Suspense でラップ
<Suspense fallback={null}>
  <ModSettings />
</Suspense>
```

## Zustand ストアの使用パターン

### 必要な値のみを取得
```typescript
// Good: 必要な値のみを destructure
const { selectedRecipe, targetQuantity, setSelectedRecipe } = useRecipeSelectionStore();

// Bad: ストア全体を取得 (不要な再レンダリングの原因)
const store = useRecipeSelectionStore();
```

### 選択的な更新
```typescript
// Good: 選択的なサブスクリプション
const settings = useSettingsStore((state) => state.settings);
const updateSettings = useSettingsStore((state) => state.updateSettings);
```

## カスタムフックの活用

### ロジックの分離
```typescript
// hooks/useProductionCalculation.ts
export function useProductionCalculation(
  selectedRecipe: Recipe | null,
  targetQuantity: number,
  data: GameData | null,
  settings: GlobalSettings,
  nodeOverrides: Map<string, NodeOverrideSettings>,
  nodeOverridesVersion: number,
  setCalculationResult: (result: CalculationResult | null) => void
) {
  useEffect(() => {
    if (!selectedRecipe || !data) {
      setCalculationResult(null);
      return;
    }
    // 計算ロジック...
  }, [selectedRecipe, targetQuantity, data, settings, nodeOverrides, nodeOverridesVersion, setCalculationResult]);
}
```

### コンポーネントでの使用
```typescript
// App.tsx
useProductionCalculation(
  selectedRecipe, 
  targetQuantity, 
  data, 
  settings, 
  nodeOverrides, 
  nodeOverridesVersion, 
  setCalculationResult
);
```

## Radix UI の使用パターン

### Dialog (モーダル)
```typescript
import * as Dialog from '@radix-ui/react-dialog';

<Dialog.Root open={isOpen} onOpenChange={setIsOpen}>
  <Dialog.Portal>
    <Dialog.Overlay className="fixed inset-0 bg-black/50" />
    <Dialog.Content className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
      {/* コンテンツ */}
    </Dialog.Content>
  </Dialog.Portal>
</Dialog.Root>
```

### Select
```typescript
import * as Select from '@radix-ui/react-select';

<Select.Root value={value} onValueChange={onChange}>
  <Select.Trigger className="...">
    <Select.Value />
  </Select.Trigger>
  <Select.Portal>
    <Select.Content>
      <Select.Item value="option1">
        <Select.ItemText>Option 1</Select.ItemText>
      </Select.Item>
    </Select.Content>
  </Select.Portal>
</Select.Root>
```

## 条件付きレンダリング

### Loading 状態
```typescript
if (isLoading) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-dark-500">
      <div className="text-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-neon-blue shadow-neon-blue mx-auto"></div>
        <p className="mt-4 text-space-200">{t('loadingGameData')}</p>
      </div>
    </div>
  );
}
```

### Error 状態
```typescript
if (error) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-dark-500">
      <div className="text-center">
        <div className="text-neon-orange text-xl mb-4">⚠ {t('error')}</div>
        <p className="text-space-200">{error}</p>
      </div>
    </div>
  );
}
```

## i18n (多言語対応)

### useTranslation の使用
```typescript
import { useTranslation } from 'react-i18next';

export function Component() {
  const { t } = useTranslation();
  
  return <h1>{t('title')}</h1>;
}
```

### 言語切り替え
```typescript
import i18n from '../i18n';

const changeLanguage = (lang: string) => {
  i18n.changeLanguage(lang);
};
```

## Tailwind CSS クラス名パターン

### レスポンシブデザイン
```typescript
<div className="grid grid-cols-1 xl:grid-cols-4 gap-6">
  {/* Mobile: 1列, XL以上: 4列 */}
</div>
```

### アニメーション
```typescript
<div className="animate-slideInLeft">
  {/* カスタムアニメーション */}
</div>
```

### ダークモード (常時有効)
```typescript
// ダークモード専用のカラーを使用
<div className="bg-dark-500 text-space-200">
  {/* dark-*, space-*, neon-* カラーを使用 */}
</div>
```

## パフォーマンス最適化

### useMemo と useCallback
```typescript
// 計算結果のメモ化
const processedData = useMemo(() => {
  return expensiveCalculation(data);
}, [data]);

// コールバックのメモ化
const handleClick = useCallback(() => {
  doSomething(value);
}, [value]);
```

### 大きなリストの仮想化
大規模なレシピグリッドなどでは、適切なページネーションや仮想スクロールを検討。

## コンポーネントのエクスポート

### Named Export を使用
```typescript
// Good: Named export
export function RecipeSelector() { /* ... */ }

// Bad: Default export (特別な理由がない限り)
export default RecipeSelector;
```

### 例外: Lazy Loading
```typescript
// Lazy loading では default export が必要
const WelcomeModal = lazy(() => import('./components/WelcomeModal').then(m => ({ default: m.WelcomeModal })));
```
