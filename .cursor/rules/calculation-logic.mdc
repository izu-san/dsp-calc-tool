---
globs: src/lib/**/*.ts
description: 計算ロジックとビジネスロジックのパターン
---

# 計算ロジックパターン

## 計算モジュールの原則

### Pure Functions
[src/lib/](mdc:src/lib/) の関数は全て純粋関数であること:
- 副作用を持たない
- 同じ入力に対して常に同じ出力
- UI から独立している

```typescript
// Good: Pure function
export function calculateProductionRate(
  recipe: Recipe,
  machine: Machine,
  proliferator: ProliferatorConfig,
  proliferatorMultiplier: { production: number; speed: number }
): number {
  // 計算ロジックのみ
  return result;
}

// Bad: 副作用がある
function calculateProductionRate(recipe, machine) {
  setGlobalState(result);  // NG: 副作用
  return result;
}
```

### 明示的な型定義
全てのパラメータと戻り値に型を定義:
```typescript
export function calculateRecipeTree(
  targetRecipe: Recipe,
  targetQuantity: number,
  data: GameData,
  settings: GlobalSettings,
  nodeOverrides: Map<string, NodeOverrideSettings>
): RecipeTreeNode {
  // ...
}
```

## [calculator.ts](mdc:src/lib/calculator.ts) - コア計算エンジン

### 主要関数

#### calculateRecipeTree
生産チェーン全体を計算:
```typescript
export function calculateRecipeTree(
  targetRecipe: Recipe,
  targetQuantity: number,
  data: GameData,
  settings: GlobalSettings,
  nodeOverrides: Map<string, NodeOverrideSettings>
): RecipeTreeNode
```

#### calculateProductionRate
レシピの生産速度を計算:
```typescript
export function calculateProductionRate(
  recipe: Recipe,
  machine: Machine,
  proliferator: ProliferatorConfig,
  proliferatorMultiplier: { production: number; speed: number }
): number
```

### 増産剤の計算

増産剤には2つのモードがあり、排他的に適用される:
- **production mode**: 出力量を増加 (1回の生産で得られるアイテム数が増加)
- **speed mode**: 生産速度を増加 (生産時間が短縮)

```typescript
// Production mode: 出力量を増加
const baseOutput = recipe.Results[0]?.count || 1;
const productionBonus = proliferator.mode === 'production' ? 1 + effectiveProductionBonus : 1;
const outputPerCraft = baseOutput * productionBonus;

// Speed mode: 生産時間を短縮
const speedBonus = proliferator.mode === 'speed' ? 1 + effectiveSpeedBonus : 1;
const timePerCraft = baseTime / machineSpeedMultiplier / speedBonus;

// 秒間生産速度
const itemsPerSecond = outputPerCraft / timePerCraft;
```

### ノードID の生成
生産ツリーの各ノードに一意のIDを付与:
```typescript
function generateNodeId(recipeSID: number, depth: number, index: number): string {
  return `${recipeSID}-${depth}-${index}`;
}
```

## [proliferator.ts](mdc:src/lib/proliferator.ts) - 増産剤計算

### 有効ボーナスの計算
Mod 設定の倍率を考慮:
```typescript
export function getEffectiveBonuses(
  proliferator: ProliferatorConfig,
  proliferatorMultiplier: { production: number; speed: number }
): {
  effectiveProductionBonus: number;
  effectiveSpeedBonus: number;
} {
  return {
    effectiveProductionBonus: proliferator.productionBonus * proliferatorMultiplier.production,
    effectiveSpeedBonus: proliferator.speedBonus * proliferatorMultiplier.speed,
  };
}
```

## [powerCalculation.ts](mdc:src/lib/powerCalculation.ts) - 電力計算

### 施設電力の計算
```typescript
export function calculateFacilityPowerConsumption(
  facilityCount: number,
  basePower: number,
  proliferator: ProliferatorConfig
): Decimal {
  const powerIncrease = 1 + proliferator.powerIncrease;
  return new Decimal(facilityCount).times(basePower).times(powerIncrease);
}
```

### ソーター電力の計算
```typescript
export function calculateSorterPowerConsumption(
  facilityCount: number,
  sorterPowerKW: number
): Decimal {
  // 各施設に2つのソーター (入力 + 出力)
  const sorterCount = facilityCount * 2;
  return new Decimal(sorterCount).times(sorterPowerKW);
}
```

## [buildingCost.ts](mdc:src/lib/buildingCost.ts) - 建設コスト計算

### コスト集計
```typescript
export function calculateBuildingCosts(
  rootNode: RecipeTreeNode,
  data: GameData
): Map<number, number> {
  const costs = new Map<number, number>();
  
  function traverse(node: RecipeTreeNode) {
    const machine = data.machines.get(node.machineId);
    if (machine && node.facilityCount > 0) {
      machine.BuildingCost.forEach(cost => {
        const currentCost = costs.get(cost.itemId) || 0;
        costs.set(cost.itemId, currentCost + cost.count * node.facilityCount);
      });
    }
    
    node.dependencies.forEach(traverse);
  }
  
  traverse(rootNode);
  return costs;
}
```

## [miningCalculation.ts](mdc:src/lib/miningCalculation.ts) - 採掘計算

### 採掘機の必要数
```typescript
export function calculateMiningMachineCount(
  itemsPerSecond: number,
  miningSpeed: number,
  veinRate: number,
  proliferator: ProliferatorConfig
): number {
  const { effectiveSpeedBonus } = getEffectiveBonuses(proliferator, { production: 1, speed: 1 });
  const speedBonus = 1 + effectiveSpeedBonus;
  
  // 採掘速度 (アイテム/秒) = 基本速度 × 鉱脈利用率 × 速度ボーナス
  const miningRate = (miningSpeed / 60) * (veinRate / 100) * speedBonus;
  
  return Math.ceil(itemsPerSecond / miningRate);
}
```

## [statistics.ts](mdc:src/lib/statistics.ts) - 統計計算

### 統計データの集計
```typescript
export function calculateStatistics(rootNode: RecipeTreeNode): Map<number, ItemStatistics> {
  const stats = new Map<number, ItemStatistics>();
  
  function traverse(node: RecipeTreeNode) {
    // 生産量を記録
    const produced = stats.get(node.outputItemId) || createEmptyStats();
    produced.totalProduced += node.productionRate;
    stats.set(node.outputItemId, produced);
    
    // 消費量を記録
    node.dependencies.forEach(dep => {
      const consumed = stats.get(dep.outputItemId) || createEmptyStats();
      consumed.totalConsumed += dep.productionRate;
      stats.set(dep.outputItemId, consumed);
      traverse(dep);
    });
  }
  
  traverse(rootNode);
  return stats;
}
```

## Decimal.js の使用

### 高精度計算
JavaScript の `number` は浮動小数点誤差があるため、`decimal.js` を使用:
```typescript
import Decimal from 'decimal.js';

// Good: Decimal を使用
const totalPower = new Decimal(facilityPower)
  .plus(sorterPower)
  .times(1000);  // MW → KW

// Bad: number を使用 (精度問題)
const totalPower = (facilityPower + sorterPower) * 1000;
```

### Decimal の操作
```typescript
// 加算
const sum = new Decimal(a).plus(b);

// 減算
const diff = new Decimal(a).minus(b);

// 乗算
const product = new Decimal(a).times(b);

// 除算
const quotient = new Decimal(a).dividedBy(b);

// 比較
const isGreater = new Decimal(a).greaterThan(b);

// number への変換
const num = decimal.toNumber();
```

## エラーハンドリング

### 防御的プログラミング
```typescript
// レシピが見つからない場合のフォールバック
const recipe = data.recipes.get(recipeId);
if (!recipe) {
  console.warn(`Recipe not found: ${recipeId}`);
  return null;
}

// 0 除算の防止
if (timePerCraft === 0) {
  return 0;
}
```

### 原材料の判定
```typescript
import { isRawMaterial } from '../constants/rawMaterials';

if (isRawMaterial(itemId)) {
  // 原材料なので、これ以上分解しない
  return node;
}
```

## テスタビリティ

### 内部関数のエクスポート
テスト用に内部関数を `@internal` コメント付きでエクスポート:
```typescript
/**
 * Calculate production rate for a recipe with given settings
 * @internal - Exported for testing
 */
export function calculateProductionRate(/* ... */): number {
  // ...
}
```

### テストデータの作成
[test/factories/](mdc:src/test/factories/) でファクトリ関数を定義:
```typescript
export function createMockRecipe(overrides?: Partial<Recipe>): Recipe {
  return {
    ID: 1,
    SID: 1,
    Name: 'Test Recipe',
    // ...
    ...overrides,
  };
}
```
